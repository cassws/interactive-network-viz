<!DOCTYPE html>
<meta charset="utf-8">

<html>
  <style>
    /* The Overlay (background) */
    body {
      font-family: Arial;
    }
    .overlay {
      /* Height & width depends on how you want to reveal the overlay (see JS below) */   
      height: 100%;
      width: 25%;
      position: fixed; /* Stay in place */
      z-index: 1; /* Sit on top */
      left: 75%;
      top: 0;
      background-color: rgba(0,0,0, 0.8); /* Black w/opacity */
    }

    .overlay-box {
      margin: 10%;
      padding: 10px;
      border-radius: 5px;
      background-color: rgba(255, 255, 255, 1); /* Black w/opacity */
    }
    .overlay-box a {
      padding: 5%;
      font-size: 20px;
      text-decoration: none;
    }
    .overlay-box h2 {
      text-align: center;
      margin: 8px;
    }

    #sidebar-content {
      margin: 10%;
      padding: 10px;
      line-height: 1.3;
      border-radius: 5px;
      background-color: rgba(255, 255, 255, 0); /* Black w/opacity */
      

    }
    #sidebar-content.active {
      background-color: rgba(255, 255, 255, 0.9); /* Black w/opacity */
    
    

    }
    #slide_background {
      transition: all 0.3s 0.3s;
    }
    #slide,
    #slide_wrapper {
      transition: all 0.3s ease-out;
      height: 100%;
      width: 50%;
    }
    #slide {
      transform: translateX(25%) translateY(20%);
    }
    .popup_visible #slide {
      transform: translateX(-25%) translateY(5%);
    }
  </style>
  <body>

      <div id="slide">
        <div style="background-color: white; padding: 10px;">

          <div>
            Welcome to the <b>people as network visualization tool!</b>
          </div>
          <hr>
          <div>
            This tool represents <b>individuals</b> (such as writers, café owners, famous community members), <b>cafés</b>, and <b>cities</b> that appear throughout the Jewish Cafés project. Here, we visualize these individuals, cafés, and cities in a network graph as points or <b>nodes</b>.
            <br >
            <br >
            <b>Relationships</b> between individuals/cafés/cities (such as a known association between a regular café-goer and a specific café) are represented as lines or <b>edges</b>. Together, these nodes and edges constitute a single diasporic <b>network</b> of Jewish café communities in the nineteenth and twentieths centuries.

            <br >
            <br >
            Try clicking on a specific node to learn more about that item, and see which other items are closely related (these other nodes will become larger and more visible as you grab onto a node). 
            <br >
            <br >
            <img src="example_of_grab.png" style ="border: 2px solid">
            <br >
            <br >
            Many nodes have additional content within our Scalar book, which you can explore further by the link on the right-hand side.
            <br >



          </div>


      
          <!-- Add an optional button to close the popup -->
          <button class="slide_close">Close</button>
        </div>
          </div>
      <div id="viz" style="height: 100%; width: 75%; ">
          
        
        <canvas height= "800" width = "700" id="myCanvas">
        </canvas>
      </div>

      <div id="network-viz-sidebar" class="overlay">
        <div class = "overlay-box">
          <h2 id="sidebar-headline">Explore relationships between people, cafés, and cities as a network</h2>        
          <div id="sidebar-link"></div>

        </div>
        <div id="sidebar-content"></div>
        </div>
      </div>


  </body>

</html>



<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="https://code.jquery.com/jquery-1.8.2.min.js"></script>
<script src="https://cdn.rawgit.com/vast-engineering/jquery-popup-overlay/1.7.13/jquery.popupoverlay.js"></script>
<script>
    $(document).ready(function() {
  
      // Initialize the plugin
        $('#slide').popup({
      outline: false, // optional
      focusdelay: 1000,
      autoopen: true,
      blur: true,
      vertical: 'center' //optional
      
    });
    console.log('thing?');
  
  
    });
  </script>
  
<script>

  // set variables to keep track of mouse , including dragging behavior (click and move)

  var mousePosX = 0;
  var mousePosY = 0;
  var dragSubjectForFade = null;
  var currentlyDragging = false;

  // set up 2d canvas

  var canvas = document.querySelector("canvas"),
      context = canvas.getContext("2d"),
      width = canvas.parentElement.clientWidth,
      height = canvas.parentElement.clientHeight;
    canvas.width = canvas.parentElement.clientWidth;
    canvas.height = canvas.parentElement.clientHeight;

//     window.onload = window.onresize = function() {

// canvas = document.getElementById('myCanvas');
// canvas.width = window.innerWidth;
// canvas.height = window.innerHeight;
// width = canvas.width;
// height = canvas.height;
// context = canvas.getContext("2d");
// }
  // set parameters for d3's force directed network simulation physics

  var simulation = d3.forceSimulation()
      .force("link", d3.forceLink().id(function(d) { return d.id; }).strength(0.23))
      .force("charge", d3.forceManyBody().strength(-450))
      .force("collide", d3.forceCollide().radius(8))
      .force("center", d3.forceCenter(width / 2, height / 2))
      .force("forceX", d3.forceX(width/2).strength(0.22) )
      .force("forceY", d3.forceY(height/2).strength(0.25) );

  // load json data with edges (or "links") and nodes ("nodes")
  // for more on preparing this data, see parsing-tools/simplify_connections.py

  d3.json("clean_scalar_data.json", function(error, graph) {
    if (error) throw error;

    simulation
        .nodes(graph.nodes)
        .on("tick", ticked);

    simulation.force("link")
        .links(graph.links);

    d3.select(canvas)
        .call(d3.drag()
            .container(canvas)
            .subject(dragsubject)
            .on("start", dragstarted)
            .on("drag", dragged)
            .on("end", dragended))
        
      d3.select(canvas.nodes).on('mouseover', function(){
        console.log("test!");
      });


    function ticked() {
      context.clearRect(0, 0, width, height);

      context.beginPath();
      graph.links.forEach(drawLink);
      context.strokeStyle = "rgba(5, 5, 5, 0.15)";
      context.stroke();

      context.fillStyle = 'rgba(0, 128, 128, 0.35)';
      context.beginPath();
      graph.nodes.forEach(drawNode);
      context.closePath();
      context.fill();

      context.fillStyle = 'black';
      context.beginPath();
      graph.nodes.forEach(drawLabel);
      context.closePath();
      context.fill();

      // context.strokeStyle = "#fff";
      // context.stroke();
    }

    function dragsubject() {
        return simulation.find(d3.event.x, d3.event.y);
    }


  function dragstarted() {
      if (!d3.event.active) simulation.alphaTarget(0.3).restart();
      // console.log(d3.event.subject);
      
      dragSubjectForFade = d3.event.subject;
      currentlyDragging = true;

      d3.event.subject.fx = d3.event.subject.x;
      d3.event.subject.fy = d3.event.subject.y;

      var sidebarHeadline = document.getElementById("sidebar-headline");
      var sidebarLink = document.getElementById("sidebar-link");

      sidebarHeadline.innerHTML = d3.event.subject.name;

      var linkToScalar = document.createElement("a")
      linkToScalar.setAttribute("href", d3.event.subject.url)
      linkToScalar.setAttribute("target", "_blank");
      linkToScalar.setAttribute("id", "scalarLink");

      while (sidebarLink.firstChild) {
          sidebarLink.removeChild(sidebarLink.firstChild);}

      sidebarLink.appendChild(linkToScalar);
      document.getElementById("scalarLink").innerHTML = "View the full page"

      if(d3.event.subject.extraData == "yes"){
          document.getElementById("sidebar-content").classList.add("active");
          imageURL = d3.event.subject.imageURL;
          description = d3.event.subject.description;
          document.getElementById("sidebar-content").innerHTML = description + "<br><hr >";

          var elem = document.createElement("img");
          elem.setAttribute("src", imageURL);
          elem.setAttribute("height", "100%");
          elem.setAttribute("width", "100%");
          elem.setAttribute("alt", description);

          document.getElementById("sidebar-content").appendChild(elem);
          

      } else {

            document.getElementById("sidebar-content").classList.remove("active");


            while (document.getElementById("sidebar-content").firstChild) {
                document.getElementById("sidebar-content").removeChild(document.getElementById("sidebar-content").firstChild);
      }
        

      }
    }

  function dragged() {
      d3.event.subject.fx = d3.event.x;
      d3.event.subject.fy = d3.event.y;
      simulation.alphaTarget(0.7);
  }

  function dragended() {
      if (!d3.event.active) simulation.alphaTarget(0);
      console.log(d3.event.subject);


      d3.event.subject.fx = null;
      d3.event.subject.fy = null;
      currentlyDragging = false;
      dragSubjectForFade = null;
  }

  function drawLink(d) {
      context.moveTo(d.source.x, d.source.y);
      context.lineTo(d.target.x, d.target.y);
  }

  function drawNode(d) {
      context.moveTo(d.x + 3, d.y);
      if (d.extraData == "yes"){
        context.arc(d.x, d.y, 16, 0, 2 * Math.PI);
      } else {
        context.arc(d.x, d.y, 3, 0, 2 * Math.PI);
      }


    // draw nodes that are either being dragged or immediate neighbor

    if (currentlyDragging)
      { if (d != dragSubjectForFade) 
          {   if (isConnected(d, dragSubjectForFade)) context.arc(d.x, d.y, 3, 0, 2 * Math.PI);
          } else 
            {
              context.arc(d.x, d.y, 3, 0, 2 * Math.PI);
            }
    }
        ;
    
  }

  function drawLabel(d) {
      var currentStyle = '';
      var currentFont = '';
      if (currentlyDragging){

          currentConnected = isConnected(d, dragSubjectForFade);

          if (d != dragSubjectForFade && currentConnected == false){
              currentStyle = 'rgba(0, 0, 0, 0.4';
              currentFont = '12px Arial';
          } else if ( d == dragSubjectForFade){
              currentStyle = 'black';
              currentFont = '30px Arial';
          } else if (currentConnected == true){
              currentStyle = 'rgba(0, 0, 0, 0.9)';
              currentFont = '16px Arial';
          


        }} else    {
        
            // if (d.extraData == "yes"){
            //     currentStyle = 'rgba(0, 0, 0, 0.82)';
            //     currentFont = 'small-caps ' + (12 + d.betweenness_centrality_score) + 'px Arial ';

            // } else {   
                currentStyle = 'rgba(0, 0, 0, 0.88)';
                currentFont = '' + (12 + d.betweenness_centrality_score) + 'px Arial';
            // }
      
      };

      context.fillStyle = currentStyle;
      context.font =  currentFont;

      context.textAlign="center";
      context.fillText(d.name, d.x + 5, d.y);

  }
      

  var linkedByIndex = {};
  graph.links.forEach(function(d) {
      linkedByIndex[d.source.index + "," + d.target.index] = 1;
  });

  // check the dictionary to see if nodes are linked
  function isConnected(a, b) {
      return linkedByIndex[a.index + "," + b.index] || linkedByIndex[b.index + "," + a.index] || a.index == b.index;
  }

  });
</script>

