<!DOCTYPE html>
<meta charset="utf-8">


<canvas width="1200" height="1000"></canvas>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script>

var dragSubjectForFade = null;
var currentlyDragging = false;

var mousePosX = 0;
var mousePosY = 0;
var canvas = document.querySelector("canvas"),
    context = canvas.getContext("2d"),
    width = canvas.width,
    height = canvas.height;

var simulation = d3.forceSimulation()
    .force("link", d3.forceLink().id(function(d) { return d.id; }).strength(0.2))
    .force("charge", d3.forceManyBody().strength(-80))
    .force("collide", d3.forceCollide().radius(18))
    .force("center", d3.forceCenter(width / 2, height / 2))
    .force("forceX", d3.forceX(width/2).strength(0.04) )
    .force("forceY", d3.forceY(height/2).strength(0.04) );


d3.json("clean_scalar_data.json", function(error, graph) {
  if (error) throw error;

  simulation
      .nodes(graph.nodes)
      .on("tick", ticked);

  simulation.force("link")
      .links(graph.links);

  d3.select(canvas)
      .call(d3.drag()
          .container(canvas)
          .subject(dragsubject)
          .on("start", dragstarted)
          .on("drag", dragged)
          .on("end", dragended))
      
    d3.select(canvas.nodes).on('mouseover', function(){
      console.log("test!");
    });


  function ticked() {
    context.clearRect(0, 0, width, height);

    context.beginPath();
    graph.links.forEach(drawLink);
    context.strokeStyle = "#aaa";
    context.stroke();

    context.fillStyle = 'rgba(0, 128, 128, 0.7';
    context.beginPath();
    graph.nodes.forEach(drawNode);
    context.closePath();
    context.fill();

    context.fillStyle = 'black';
    context.beginPath();
    graph.nodes.forEach(drawLabel);
    context.closePath();
    context.fill();

    context.strokeStyle = "#fff";
    context.stroke();
  }

  function dragsubject() {
    return simulation.find(d3.event.x, d3.event.y);
  }


function dragstarted() {
  if (!d3.event.active) simulation.alphaTarget(0.3).restart();
  // console.log(d3.event.subject);
  
  dragSubjectForFade = d3.event.subject;
  currentlyDragging = true;

  d3.event.subject.fx = d3.event.subject.x;
  d3.event.subject.fy = d3.event.subject.y;
}

function dragged() {
  d3.event.subject.fx = d3.event.x;
  d3.event.subject.fy = d3.event.y;
}

function dragended() {
  if (!d3.event.active) simulation.alphaTarget(0);
  console.log(d3.event.subject.url);

  // create a possibility to go to this URL
  window.open(d3.event.subject.url, '_blank');
  d3.event.subject.fx = null;
  d3.event.subject.fy = null;
  currentlyDragging = false;
  dragSubjectForFade = null;
}

function drawLink(d) {
  context.moveTo(d.source.x, d.source.y);
  context.lineTo(d.target.x, d.target.y);
}

function drawNode(d) {
  context.moveTo(d.x + 3, d.y);
  context.arc(d.x, d.y, 2, 0, 2 * Math.PI);

  // draw nodes that are either being dragged or immediate neighbor

  if (currentlyDragging)
  { if (d != dragSubjectForFade) 
    {   if (isConnected(d, dragSubjectForFade)) context.arc(d.x, d.y, 3, 0, 2 * Math.PI);
      ; 
    } else 
    {
      context.arc(d.x, d.y, 3, 0, 2 * Math.PI);
    }
  }
      ;
  
}

function drawLabel(d) {
    if (currentlyDragging && (d != dragSubjectForFade && !isConnected(d, dragSubjectForFade))){
      context.fillStyle = 'rgba(0, 0, 0, 0.78';
      context.font = '10px Helvetica';
    } else if (currentlyDragging && d == dragSubjectForFade){
      context.fillStyle = 'black';
      context.font = '32px Helvetica';
    } else if (currentlyDragging && (isConnected(d, dragSubjectForFade))){
      context.fillStyle = 'rgba(0, 0, 0, 0.8';
      context.font = '20px Helvetica';

    } else    {    
      context.fillStyle = 'black';
      context.font = '12px Helvetica'};

    context.fillText(d.name, d.x + 5, d.y);

  
}
    

var linkedByIndex = {};
graph.links.forEach(function(d) {
    linkedByIndex[d.source.index + "," + d.target.index] = 1;
});

// check the dictionary to see if nodes are linked
function isConnected(a, b) {
    return linkedByIndex[a.index + "," + b.index] || linkedByIndex[b.index + "," + a.index] || a.index == b.index;
}

});
</script>
