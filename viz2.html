<!DOCTYPE html>
<meta charset="utf-8">

<html>
  <style>
    /* The Overlay (background) */
    body {
      font-family: Arial;
    }
    .overlay {
      /* Height & width depends on how you want to reveal the overlay (see JS below) */   
      height: 100%;
      width: 25%;
      position: fixed; /* Stay in place */
      z-index: 1; /* Sit on top */
      left: 75%;
      top: 0;
      background-color: rgba(0,0,0, 0.8); /* Black w/opacity */
    }

    .overlay-box {
      margin: 10%;
      padding: 10px;
      border-radius: 5px;
      background-color: rgba(255, 255, 255, 1); /* Black w/opacity */
    }
    .overlay-box a {
      padding: 5%;
      font-size: 20px;
      text-decoration: none;
    }
    .overlay-box h2 {
      text-align: center;
      margin: 8px;
    }

    #sidebar-content {
      margin: 10%;
      padding: 10px;
      line-height: 1.3;
      border-radius: 5px;
      background-color: rgba(255, 255, 255, 0); /* Black w/opacity */
      

    }
    #sidebar-content.active {
      background-color: rgba(255, 255, 255, 0.9); /* Black w/opacity */
      

    }
  </style>
  <body>
      <div id="viz" style="height: 100%; width: 67%">
        <canvas width="1200" height="800"></canvas>
      </div>
      <div id="network-viz-sidebar" class="overlay">
        <div class = "overlay-box">
          <h2 id="sidebar-headline">  Visualize the unique convergences of people as networks that change over time. </h2>        
          <div id="sidebar-link"></div>

        </div>
        <div id="sidebar-content"></div>
        </div>
      </div>

  </body>

</html>



<script src="https://d3js.org/d3.v4.min.js"></script>
<script>

  var dragSubjectForFade = null;
  var currentlyDragging = false;

  var mousePosX = 0;
  var mousePosY = 0;
  var canvas = document.querySelector("canvas"),
      context = canvas.getContext("2d"),
      width = canvas.width,
      height = canvas.height;

  var simulation = d3.forceSimulation()
      .force("link", d3.forceLink().id(function(d) { return d.id; }).strength(0.1))
      .force("charge", d3.forceManyBody().strength(-390))
      .force("collide", d3.forceCollide().radius(19).iterations(2))
      .force("center", d3.forceCenter(width / 2 - 100, height / 2))
      .force("forceX", d3.forceX(width/2).strength(0.14) )
      .force("forceY", d3.forceY(height/2).strength(0.18) );


  d3.json("clean_scalar_data.json", function(error, graph) {
    if (error) throw error;

    simulation
        .nodes(graph.nodes)
        .on("tick", ticked);

    simulation.force("link")
        .links(graph.links);

    d3.select(canvas)
        .call(d3.drag()
            .container(canvas)
            .subject(dragsubject)
            .on("start", dragstarted)
            .on("drag", dragged)
            .on("end", dragended))
        
      d3.select(canvas.nodes).on('mouseover', function(){
        console.log("test!");
      });


    function ticked() {
      context.clearRect(0, 0, width, height);

      context.beginPath();
      graph.links.forEach(drawLink);
      context.strokeStyle = "rgba(77, 109, 126, 0.2)";
      context.stroke();

      context.fillStyle = 'rgba(0, 128, 128, 0.75)';
      context.beginPath();
      graph.nodes.forEach(drawNode);
      context.closePath();
      context.fill();

      context.fillStyle = 'black';
      context.beginPath();
      graph.nodes.forEach(drawLabel);
      context.closePath();
      context.fill();

      // context.strokeStyle = "#fff";
      // context.stroke();
    }

    function dragsubject() {
        return simulation.find(d3.event.x, d3.event.y);
    }


  function dragstarted() {
    if (!d3.event.active) simulation.alphaTarget(0.3).restart();
    // console.log(d3.event.subject);
    
    dragSubjectForFade = d3.event.subject;
    currentlyDragging = true;

    d3.event.subject.fx = d3.event.subject.x;
    d3.event.subject.fy = d3.event.subject.y;

    var sidebarHeadline = document.getElementById("sidebar-headline");
    var sidebarLink = document.getElementById("sidebar-link");

    sidebarHeadline.innerHTML = d3.event.subject.name;

    var linkToScalar = document.createElement("a")
    linkToScalar.setAttribute("href", d3.event.subject.url)
    linkToScalar.setAttribute("target", "_blank");
    linkToScalar.setAttribute("id", "scalarLink");

    while (sidebarLink.firstChild) {
        sidebarLink.removeChild(sidebarLink.firstChild);}

    sidebarLink.appendChild(linkToScalar);
    document.getElementById("scalarLink").innerHTML = "View the full page"

    if(d3.event.subject.extraData == "yes"){
        document.getElementById("sidebar-content").classList.add("active");
        imageURL = d3.event.subject.imageURL;
        description = d3.event.subject.description;
        document.getElementById("sidebar-content").innerHTML = description + "<br><hr >";

        var elem = document.createElement("img");
        elem.setAttribute("src", imageURL);
        elem.setAttribute("height", "100%");
        elem.setAttribute("width", "100%");
        elem.setAttribute("alt", description);

        document.getElementById("sidebar-content").appendChild(elem);
        

    } else {

        document.getElementById("sidebar-content").classList.remove("active");


      while (document.getElementById("sidebar-content").firstChild) {
        document.getElementById("sidebar-content").removeChild(document.getElementById("sidebar-content").firstChild);
    }
      

    }
  }

  function dragged() {
      d3.event.subject.fx = d3.event.x;
      d3.event.subject.fy = d3.event.y;
      simulation.alphaTarget(0.7);
  }

  function dragended() {
      if (!d3.event.active) simulation.alphaTarget(0);
      console.log(d3.event.subject);


      d3.event.subject.fx = null;
      d3.event.subject.fy = null;
      currentlyDragging = false;
      dragSubjectForFade = null;
  }

  function drawLink(d) {
      context.moveTo(d.source.x, d.source.y);
      context.lineTo(d.target.x, d.target.y);
  }

  function drawNode(d) {
      context.moveTo(d.x + 3, d.y);
      context.arc(d.x, d.y, 2, 0, 2 * Math.PI);


    // draw nodes that are either being dragged or immediate neighbor

    if (currentlyDragging)
      { if (d != dragSubjectForFade) 
          {   if (isConnected(d, dragSubjectForFade)) context.arc(d.x, d.y, 3, 0, 2 * Math.PI);
          } else 
            {
              context.arc(d.x, d.y, 3, 0, 2 * Math.PI);
            }
    }
        ;
    
  }

  function drawLabel(d) {
      var currentStyle = '';
      var currentFont = '';
      if (currentlyDragging){

          currentConnected = isConnected(d, dragSubjectForFade);

          if (d != dragSubjectForFade && currentConnected == false){
              currentStyle = 'rgba(0, 0, 0, 0.78';
              currentFont = '6px Arial';
          } else if ( d == dragSubjectForFade){
              currentStyle = 'black';
              currentFont = '28px Arial';
          } else if (currentConnected == true){
              currentStyle = 'rgba(0, 0, 0, 0.8)';
              currentFont = '16px Arial';
          


        }} else    {
        
            if (d.id == "http://scalar.usc.edu/works/cafs-cities-and-people/network-visualization-of-caf-regulars.1"){
                currentStyle = 'rgba(0, 0, 0, 0.82';
                currentFont = '10px Arial';
            } else if (d.extraData == "yes"){
                currentStyle = 'rgba(0, 0, 0, 0.99)';
                currentFont = 'small-caps ' + (12 + d.betweenness_centrality_score) + 'px Arial ';

            } else {   
                currentStyle = 'rgba(0, 0, 0, 0.82)';
                currentFont = '' + (10 + d.betweenness_centrality_score) + 'px Arial';
            }
      
      };

      context.fillStyle = currentStyle;
      context.font =  currentFont;

      context.textAlign="center";
      context.fillText(d.name, d.x + 5, d.y);

  }
      

  var linkedByIndex = {};
  graph.links.forEach(function(d) {
      linkedByIndex[d.source.index + "," + d.target.index] = 1;
  });

  // check the dictionary to see if nodes are linked
  function isConnected(a, b) {
      return linkedByIndex[a.index + "," + b.index] || linkedByIndex[b.index + "," + a.index] || a.index == b.index;
  }

  });
</script>
